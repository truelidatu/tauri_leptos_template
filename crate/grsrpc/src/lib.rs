use std::{
    cell::RefCell,
    collections::VecDeque,
    marker::PhantomData,
    pin::Pin,
    rc::Rc,
    task::{Context, Poll},
};

use futures_core::{Stream, future::LocalBoxFuture};
use futures_util::{FutureExt, Sink};
use futures_util::{SinkExt, stream::FuturesUnordered};
use futures_util::{StreamExt, TryFutureExt};
use serde::{Deserialize, Serialize, de::DeserializeOwned};
pub mod client;
pub mod service;
pub mod task_set;

#[doc(hidden)]
pub use bincode;
#[doc(hidden)]
pub use futures_channel;
#[doc(hidden)]
pub use futures_core;
#[doc(hidden)]
pub use futures_util;
// #[doc(hidden)]
// pub use pin_utils;
#[doc(hidden)]
pub use serde;

#[doc(hidden)]
#[derive(Serialize, Deserialize)]
pub enum Message<Request, Response> {
    Request(usize, Request),
    Abort(usize),
    Response(usize, Response),
}

pub struct Builder<C, S, T> {
    client: PhantomData<C>,
    service: S,
    transport: T,
}

impl<T> Builder<(), (), T> {
    pub fn new(transport: T) -> Self {
        Self {
            transport,
            client: PhantomData::<()>,
            service: (),
        }
    }
}

impl<S, T> Builder<(), S, T> {
    pub fn with_client<C: client::Client>(self) -> Builder<C, S, T> {
        let Builder {
            transport, service, ..
        } = self;
        Builder {
            transport,
            client: PhantomData::<C>,
            service,
        }
    }
}

impl<C, T> Builder<C, (), T> {
    /// Configure the RPC interface with a service that implements methods
    /// that can be called from the other side of the channel. To use this method,
    /// you need to specify the type `S` which is the service type generated by the
    /// attribute macro [`macro@service`]. The implementation parameter is then an
    /// instance of something that implements the trait to which to applied the
    /// [`macro@service`] macro. For example, if you have a trait `Calculator` to
    /// which you have applied [`macro@service`], you would use this method as follows:
    /// ```
    /// struct CalculatorServiceImpl;
    /// impl Calculator for CalculatorServiceImpl { /* add Calculator's methods */}
    /// let server = Builder::new(some_interface)
    ///     .with_service<CalculatorService<_>>(CalculatorServiceImpl)
    ///     .build();
    /// ```
    pub fn with_service<S: service::Service>(
        self,
        implementation: impl Into<S>,
    ) -> Builder<C, S, T> {
        let service = implementation.into();
        let Builder {
            transport, client, ..
        } = self;
        Builder {
            transport,
            client,
            service,
        }
    }
}

impl<C, T, E> Builder<C, (), T>
where
    C: client::Client + From<client::Configuration<C::Request, C::Response>> + 'static,
    <C as client::Client>::Response: DeserializeOwned,
    <C as client::Client>::Request: Serialize,
    T: Stream<Item = Vec<u8>> + Sink<Vec<u8>, Error = E> + Unpin + 'static,
{
    /// Build function for client-only RPC interfaces.
    pub fn build(self) -> (C, RpcEngine<()>) {
        let (mut task_set_handle, task_set) =
            task_set::TaskSet::new(Box::new(task_set::SystemTaskReaper));
        let client_callback_map: Rc<RefCell<client::CallbackMap<C::Response>>> = Default::default();
        // let (abort_requests_tx, abort_requests_rx) = futures_channel::mpsc::unbounded();
        let client_callback_map_cloned = client_callback_map.clone();
        let (mut transport_tx, mut transport_rx) = self.transport.split();
        let transport_incoming = async move {
            while let Some(array) = transport_rx.next().await {
                let message = array;
                match bincode::deserialize::<Message<(), C::Response>>(&message).unwrap() {
                    Message::Response(seq_id, response) => {
                        if let Some(callback_tx) =
                            client_callback_map_cloned.borrow_mut().remove(&seq_id)
                        {
                            // TODO: handle error
                            let _ = callback_tx.send(response);
                        }
                    }
                    _ => panic!("client received a server message"),
                }
            }
            Ok(())
        };

        let (request_tx, mut request_rx) =
            futures_channel::mpsc::unbounded::<(usize, C::Request)>();
        let (abort_tx, mut abort_rx) = futures_channel::mpsc::unbounded::<usize>();
        // let mut task_set_handle_clone = task_set_handle.clone();
        let transport_outgoing = async move {
            loop {
                let maybe_msg = futures_util::select! {
                    maybe_req = request_rx.next() => {
                        if let Some((seq_id, msg)) = maybe_req {
                            // TODO: optimize, serialize on client rpc fn to avoid copy?
                            let msg = bincode::serialize(&Message::<<C as client::Client>::Request, ()>::Request(seq_id, msg)).unwrap();
                            // send_task_list.push(transport_tx.send(msg));
                            transport_tx.send(msg).await;
                        }
                        else {
                            // No more requests, break the loop
                            break;
                        }
                    }
                    maybe_abort = abort_rx.next() => {
                        if let Some(seq_id) = maybe_abort {
                            let msg = bincode::serialize(&Message::<<C as client::Client>::Request, ()>::Abort(seq_id)).unwrap();
                            // transport_tx.send(msg).await;
                            transport_tx.send(msg).await;
                        }
                    }
                };
            }

            Ok(())
        };

        let client = C::from((client_callback_map, request_tx, abort_tx));
        task_set_handle.add(transport_incoming);
        task_set_handle.add(transport_outgoing);
        let engine = RpcEngine {
            task: task_set.boxed_local(),
        };
        (client, engine)
    }
}

impl<S, T, E> Builder<(), S, T>
where
    S: service::Service + 'static,
    <S as service::Service>::Request: DeserializeOwned,
    <S as service::Service>::Response: Serialize,
    T: Stream<Item = Vec<u8>> + Sink<Vec<u8>, Error = E> + Unpin + 'static,
{
    /// Build function for server-only RPC interfaces.
    pub fn build(self) -> RpcEngine<()> {
        let Builder {
            transport, service, ..
        } = self;

        // let (abort_requests_tx, abort_requests_rx) = futures_channel::mpsc::unbounded();
        let (mut task_set_handle, task_set) =
            task_set::TaskSet::new(Box::new(task_set::SystemTaskReaper));
        let (mut transport_tx, mut transport_rx) = transport.split();
        let (response_tx, mut response_rx) =
            futures_channel::mpsc::unbounded::<(usize, Option<<S as service::Service>::Response>)>(
            );

        let service = Rc::new(service);
        let mut task_set_handle_clone = task_set_handle.clone();
        let transport_incoming = async move {
            while let Some(array) = transport_rx.next().await {
                match bincode::deserialize::<Message<<S as service::Service>::Request, ()>>(&array)
                    .unwrap()
                {
                    Message::Request(seq_id, request) => {
                        let (abort_tx, abort_rx) = futures_channel::oneshot::channel::<()>();
                        let response_tx_clone = response_tx.clone();
                        let service_clone = service.clone();
                        task_set_handle_clone.add(async move {
                            let response = service_clone.execute(seq_id, abort_rx, request).await;
                            response_tx_clone.unbounded_send(response).unwrap();
                            Ok(())
                        });
                    }
                    // Message::Abort(seq_id) => {
                    //     let _ = abort_tx.send(());
                    // }
                    _ => panic!("server received a client message"),
                }
            }
            Ok(())
        };

        let (abort_tx, mut abort_rx) = futures_channel::mpsc::unbounded::<usize>();
        let transport_outgoing = async move {
            loop {
                futures_util::select! {
                    maybe_response = response_rx.next() => {
                        if let Some((seq_id, maybe_response)) = maybe_response {
                            if let Some(response) = maybe_response {
                                let msg = bincode::serialize(&Message::<(), <S as service::Service>::Response>::Response(seq_id, response)).unwrap();
                                let _ = transport_tx.send(msg).await;
                            }
                        }
                    }
                }
            }

            Ok(())
        };

        task_set_handle.add(transport_incoming);
        task_set_handle.add(transport_outgoing);
        let engine = RpcEngine {
            task: task_set.boxed_local(),
        };
        engine
    }
}

pub struct RpcEngine<E> {
    task: LocalBoxFuture<'static, Result<(), E>>,
}

impl<E> Future for RpcEngine<E> {
    type Output = Result<(), E>;
    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        self.task.poll_unpin(cx)
    }
}
